<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>UER</title>
		<style>
			body { margin: 0; background-color: black;}
			canvas { width: 100%; height: 100% }

			#glCanvas
			{
				opacity: 20%;
			}


			#container {
  position: relative;

}
#container #glCanvas, #overlay {
  position: absolute;

}

#overlay
{
	text-align: center;
	color:  white;
	font-size:  30px;
}


		</style>
	</head>
	<body>
		
		
			<div id="container">
  <canvas id="glCanvas"></canvas>
  <div id="overlay">Progress: 0%</div>
</div>
		
		
		<script src="https://unpkg.com/fflate"></script>

		<script src="https://threejs.org/build/three.js"></script>
		<script src="/js/controls/OrbitControls.js"></script>
		<script src="/js/loaders/STLLoader.js"></script>
		<script src="/js/loaders/TDSLoader.js"></script>
		<script src="/js/loaders/FBXLoader.js"></script>
		<script src="/js/roomEnvironment.js"></script>
		<script src="/js/lights/RectAreaLightUniformsLib.js"></script>
		<script src="/js/helpers/RectAreaLightHelper.js"></script>
		<script src="roverParts/wheel.js"></script>
		<script src="roverParts/chassis.js"></script>
		<script src="roverParts/camera.js"></script>
		<script src="roverParts/roboticArm.js"></script>
		<script src="rover.js"></script>
		<script>


		function setProgress(progress)
		{
			if(progress == 96)
				document.getElementById("overlay").innerHTML = "Progress: " + Math.floor(progress) + "%, loading terrain, please wait, this may take a minute";
			else
				document.getElementById("overlay").innerHTML = "Progress: " + Math.floor(progress) + "%";
		}

		function removeOverlay()
		{
			var link = document.getElementById('overlay');
			link.style.display = 'none';
			var link2 = document.getElementById('glCanvas');
			link2.style.opacity = '100%';
		}


		let controls, plateBg;

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		var canvReference = document.getElementById("glCanvas");
		const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvReference});
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor (0x111111, 1);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.outputEncoding = THREE.sRGBEncoding;
		scene.fog = new THREE.FogExp2( 0x111111, 0.020 );

		//Load background texture
		const loader = new THREE.TextureLoader();
		loader.load('textures/bg.jpeg' , function(texture)
		{
			scene.background = texture;  
		});

		window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){

			 	camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


		const axesHelper = new THREE.AxesHelper( 5 );
		//scene.add( axesHelper );

		const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.01 );
		hemiLight.color.setHSL( 0.05, 0.1, 0.5 );
				hemiLight.groundColor.setHSL( 0.05, 0.05, 0.7 );
		hemiLight.position.set( 20, 25, 20 );
		scene.add( hemiLight );


		let dirLightRover = new THREE.DirectionalLight( 0xfdfbd3, 0.5 );
		dirLightRover.color.setHSL( 0.1, 1, 0.85 );
		dirLightRover.position.set( 15, 8, 15 );
		scene.add( dirLightRover );

		const helper = new THREE.DirectionalLightHelper( dirLightRover, 5 );
		//scene.add( helper );

		dirLightRover.castShadow = true;

		dirLightRover.shadow.mapSize.width = 1024;
		dirLightRover.shadow.mapSize.height = 1024;

		dirLightRover.shadowCameraLeft = -20;
		dirLightRover.shadowCameraRight = 20;
		dirLightRover.shadowCameraTop = 20;
		dirLightRover.shadowCameraBottom = -20;


	


		/*const geometryBg = new THREE.BoxGeometry(800, 0.3, 800);
		const materialBg = new THREE.MeshPhongMaterial( { color: 0x454545} );
		plateBg = new THREE.Mesh( geometryBg, materialBg );
		plateBg.receiveShadow = true;
		plateBg.position.y = 0 * stlScale - 0.3;
		scene.add(plateBg);*/

		


		loadRover();

		camera.position.z = 0;
		camera.rotation.x = 0;
		camera.position.y = 32;
		let tmp = new THREE.Vector3();
		
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.rotateSpeed = 1;
    controls.zoomSpeed = 1;
    controls.panSpeed = 1;
    controls.enableZoom = true;

		let currentRoverPart = roverStructure.articulatedBar.left.front;

		let rot = 0;



		function animate()
		{
			requestAnimationFrame( animate );
			controls.update();
			if(ready)
			{
				/*steerWheel(0, rot+=0.06);
				steerWheel(1, rot);
				steerWheel(2, rot);
				steerWheel(3, rot);

				rotateWheel(0, 0.01);
				rotateWheel(1, 0.01);
				rotateWheel(2, 0.01);
				rotateWheel(3, 0.01);*/
				
				/*setArticulatedBarAngle(Math.sin(rot/4)/3);

				setCameraTilt(Math.sin(rot/2)/3);
				setCameraRotation(Math.sin(rot)/3);
*/
				//setRoverRotation(0, rot/4, 0);


				roverStructure.camera.cameraCase.lookAt(camera.position);

				roverStructure.camera.cameraCase.rotation.reorder("YXZ");
				roverStructure.camera.cameraCase.rotation.y -= Math.PI/2;

				setCameraTilt(roverStructure.camera.cameraCase.rotation.x);
				roverStructure.camera.cameraCase.rotation.x = 0;
				


			}
			renderer.render( scene, camera );
		}
		

		animate();
		</script>
		<br>
	</body>
</html>
